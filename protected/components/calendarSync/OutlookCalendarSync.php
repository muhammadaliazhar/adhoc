<?php
/***********************************************************************************
* Copyright (C) 2011-2019 X2 Engine Inc. All Rights Reserved.
*
* X2 Engine Inc.
* P.O. Box 610121
* Redwood City, California 94061 USA
* Company website: http://www.x2engine.com
*
* X2 Engine Inc. grants you a perpetual, non-exclusive, non-transferable license
* to install and use this Software for your internal business purposes only
* for the number of users purchased by you. Your use of this Software for
* additional users is not covered by this license and requires a separate
* license purchase for such users. You shall not distribute, license, or
* sublicense the Software. Title, ownership, and all intellectual property
* rights in the Software belong exclusively to X2 Engine. You agree not to file
* any patent applications covering, relating to, or depicting this Software
* or modifications thereto, and you agree to assign any patentable inventions
* resulting from your use of this Software to X2 Engine.
*
* THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT WARRANTIES OF ANY KIND, EITHER
* EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT.
***********************************************************************************/






class OutlookCalendarSync extends CalDavSync {
    
    /**
     * The URL format for Outlook calendars
     * @var string 
     */
    public $calendarUrl = 'https://graph.microsoft.com/v1.0/me/calendars/{calendarId}/events';

    /**
     * Returns an oAuthToken generated by the OutlookAuthenticator class
     * @return array
     * @throws CException
     */
    protected function authenticate() {
        $client = new OutlookAuthenticator('calendar');
        $access = $client->getAccessToken();
        return array(
            'oAuthToken' => $access,
            'username' => null,
            'password' => null,
        );
    }
    
    /**
     * Retrieves up to date information about the status of a remote calendar,
     * including the ctag and syncToken which can be used to determine if any
     * changes have been made and generate a diff of those changes
     * @return array
     */
    protected function getSyncInfo() {
    }
    
    /**
     * Handles synchronization of X2 and CalDav calendars. If an X2Calendar does
     * not yet have a ctag (it has never before been synced) an outbount sync is
     * performed to transfer X2 calendar events into the CalDav server. If a
     * sync token has been provided, it will use that instead of attempting a
     * full sync.
     */
    public function sync($start = 0, $end = 0) { 
            if (isset($this->owner->syncToken)) {
                $this->syncWithToken();
            } else {
                $this->syncWithoutToken($start, $end);
            }
            $this->owner->save();
    }
    
    /**
     * Performs a full synchronization in the event that there is no token to
     * calculate a diff from. This function is called after outboundSync to ensure
     * no Actions which were already in X2 are deleted
     */
    protected function syncWithoutToken($start = 0, $end = 0) {
        if($start == 0 && $end == 0) {
            return;
        } else {
            //get start date of the month
            $dt_start = new DateTime("@$start");
            $startDate =  $dt_start->format('Y-m-d@H:i:s');
            $start_result = str_replace('@', 'T', $startDate); 
            //get end date of the month
            $dt_end = new DateTime("@$end");
            $endDate =  $dt_end->format('Y-m-d@H:i:s');
            $end_result = str_replace('@', 'T', $endDate); 
        }
        $temp_url = $this->owner->remoteCalendarUrl;
        $temp_url = str_replace('events', 'calendarView', $temp_url);
        $temp_url = $temp_url ."?startDateTime=".$start_result."&endDateTime=".$end_result."&top=1000";
        
        // Get calendar events for month the current user is viewing on the calendar view 
        $calendarEvents = $this->client->getOutlook($temp_url, "");
        
        //outlook get request previously.
        //$calendarEvents = $this->client->getOutlook($this->owner->remoteCalendarUrl, "");
        $paths = $this->createUpdateActions($calendarEvents, true);
        $pathList = AuxLib::bindArray($paths);
        $bindParams = array(':calId' => $this->owner->id);
        $deletedActionCmd = Yii::app()->db->createCommand()
                ->select('a.id')
                ->from('x2_actions a')
                ->join('x2_action_meta_data b', 'a.id = b.actionId');
        if(!empty($pathList)) {
            $bindParams = array_merge($bindParams, $pathList);
            $deletedActionCmd->where('a.calendarId = :calId AND b.remoteCalendarUrl NOT IN ' . AuxLib::arrToStrList(array_keys($pathList)), $bindParams);
        } else {
            $deletedActionCmd->where('a.calendarId = :calId', $bindParams);
        }

        $deletedActions = $deletedActionCmd->queryColumn();
        if(!empty($deletedActions)){
            $actionIdParams = AuxLib::bindArray($deletedActions);
            $reminderIds = Yii::app()->db->createCommand()
                    ->select('id')
                    ->from('x2_events')
                    ->where('associationType = "Actions" AND associationId IN '. AuxLib::arrToStrList($actionIdParams). ' AND type = "calendar_event"')
                    ->queryColumn();
            X2Model::model('Events')->deleteByPk($reminderIds);
            X2Model::model('Actions')->deleteByPk($deletedActions);
        }
    }
    
    /**
     * Creates or updates Actions in X2 from remote calendar event data
     * @param array $calendarData XML data of remote calendar events
     * @param boolean $return Whether or not to return the paths
     * @return array A list of paths of created/updated events
     */
    protected function createUpdateActions($calendarData, $return = false) {
        if ($return) {
            $paths = array();
        }
        
        $calendar = CJSON::decode($calendarData['body']);
        $calendars = $calendar['value'];
        foreach ($calendars as $event) {
            $eventEtag = $event['@odata.etag'];
            $eventVObj = $event;
            $actionMetaData = ActionMetaData::model()->findByAttributes(array('remoteCalendarUrl' => $event['id']));
            
            if ($return)
                $paths[] = $event['id'];
            
            if (isset($actionMetaData)) {
                $action = X2Model::model('Actions')->findByPk($actionMetaData->actionId);
                $action->sendOutlook = 0;
                
                $this->updateAction($action, $eventVObj, array(
                    'etag' => $eventEtag,
                    'reminder' => $eventVObj['isReminderOn'] == 1 ? 1 : 0,
                    'reminderMinutes' => $eventVObj['reminderMinutesBeforeStart'],
                    'location' => $event['location'],
                ));
            } else {
                $this->createAction($eventVObj, array(
                    'etag' => $eventEtag,
                    'reminder' => $eventVObj['isReminderOn'] == 1 ? 1 : 0,
                    'remoteCalendarUrl' => $event['id'],
                    'location' => $event['location'],
                ), 0);
            }
        }
        
        if ($return) {
            return $paths;
        }
    }
    
    /**
     * Updates an Action from a SabreDav VEvent
     */
    protected function updateAction($action, $calObject, $params = array()) {
        if($action->etag == $params['etag'])
            return;

        // If the action does have a reminder, ensure a notification record is made or updated as needed
        if($params['reminder'] == 1) {
            $action->reminder = $params['reminder'];
            $reminderTime = (($action->dueDate / 60) - $params['reminderMinutes']) * 60;
            $notification = Notification::model()->findByAttributes(array('type' => 'action_reminder', 'modelType' => 'Actions', 'modelId' => $action->id));
            if(isset($notification)) {
                $notification->createDate = $reminderTime;
                $notification->save(); 
            } else  
                $action->createNotifications(null, $reminderTime, 'action_reminder');
        }
            
        $action->etag = $params['etag'];
        $action->location = $params['location']['displayName'];
        $this->setActionAttributes($action, $calObject);

        $action->save();
    }
    
    /**
     * Creates an Action from a SabreDav VEvent
     */
    protected function createAction($calObject, $params = array(), $send = 1) {
        $action = new Actions;
        if($send == 0)
            $action->sendOutlook = 0;
        
        $action->etag = $params['etag'];
        $action->remoteCalendarUrl = $params['remoteCalendarUrl'];
        $action->reminder = $calObject['isReminderOn'];
        $action->location = $calObject['location']['displayName'];

        $this->setActionAttributes($action, $calObject, true);
        
        $action->save();
        
        // Set reminder time
        if($action->reminder == 1) {
            $reminderTime = (($action->dueDate / 60) - $calObject['reminderMinutesBeforeStart']) * 60;
            $notification = Notification::model()->findByAttributes(array('type' => 'action_reminder', 'modelType' => 'Actions', 'modelId' => $action->id));
            if(isset($notification)) {
                $notification->createDate = $reminderTime;
                $notification->save();
            } else {
                $action->notificationTime = $reminderTime;
                $action->createNotifications('assigned', $reminderTime, 'action_reminder');
            }
        }
    }
    
    /**
     * Converts a SabreDav VEvent object's attributes into X2 friendly attributes
     * and sets the provided Action's attributes to the processed data.
     * 
     * TODO: Handle recurring events
     */
    protected function setActionAttributes(&$action, $calObject, $newAction = false) {
        $action->actionDescription = $calObject['subject'];
        if (!empty($calObject['bodyPreview'])) {
            if (!empty($calObject['subject'])) {
                $action->actionDescription .= "\n" . $calObject['bodyPreview'];
            } else {
                $action->actionDescription = $calObject['bodyPreview'];
            }
        }
       
        if($newAction) { 
            $action->visibility = 1;
            $action->assignedTo = $this->owner->createdBy;
            $action->calendarId = $this->owner->id;
            //$action->associationType = 'calendar';
            //$action->associationName = 'Calendar';
            $action->type = 'event';
            $action->remoteSource = 1;
            // Date set
            $tz = date_default_timezone_get();
            date_default_timezone_set('UTC');
            $action->dueDate = strtotime($calObject['start']['dateTime']);
            if(is_null($calObject['end']['dateTime'])){
                $action->completeDate = $action->dueDate;
            } else {
                $action->completeDate = strtotime($calObject['end']['dateTime']);
            }
            date_default_timezone_set($tz);
            if ($calObject['isAllDay'] == true) { // All day event
                $action->allDay = 1;
            }     
        }
    }
    
    /**
     * Either create or update a remote calendar event associated with an Action
     */
    public function syncActionToCalendar($action) {
        if (empty($action->remoteCalendarUrl)) {
            $calObject = $this->createCalObject($action);
        } else {
            $calObject = $this->updateCalObject($action);
        }
    }
    
    /** CUSTOM FOR OUTLOOK
     * Creates a VEvent object from an Action and sends it to a remote CalDav server
     */
    protected function createCalObject($action) {
        $calObj = new Sabre\VObject\Component\VCalendar();
        $vevent = new Sabre\VObject\Component\VEvent('VEVENT');
        
        //$this->setEventAttributes($vevent, $action);
        $uniqueId = UUID::v4();
        $vevent->add('UID', $uniqueId);
        $calObj->add($vevent);
       
        //microsoft only accepts UTC
        $timezone = "UTC";

        if(!empty($action->associationType) && $action->associationType != "None"  && $action->associationType != "calendar" && $action->associationType != "opportunities"){
            $assocRecord = ucfirst($action->associationType)::model()->findByPk($action->associationId);
            $phone = $assocRecord->hasAttribute("phone") ? "$assocRecord->phone" : "$assocRecord->c_phone";
            $email = $assocRecord->hasAttribute("email") ? "$assocRecord->email" : "$assocRecord->c_email";
            $actionText = ActionText::model()->findByAttributes(array("actionId"=>$action->id));
            $actionText->text .= "\n";
            $actionText->text .= "Name: $assocRecord->name\n";
            $actionText->text .= "Phone: $phone\n";
            $actionText->text .= "Email: $email\n";
            $actionText->text .= "https://sydney.tworld.com/index.php/$action->associationType/$action->associationId";
            $actionText->save();
            $action->actionDescriptionTemp = $actionText->text;
        }


        // Set reminder time
        if($action->reminder == 1) {
            $reminderTime = (($action->dueDate / 60) - $action->notificationTime) * 60; 
            $notification = Notification::model()->findByAttributes(array('type' => 'action_reminder', 'modelType' => 'Actions', 'modelId' => $action->id));
            if(isset($notification)) {
                $notification->createDate = $reminderTime;
                $notification->save();
            } else {
                $action->notificationTime = $reminderTime;
                $action->createNotifications('assigned', $reminderTime, 'action_reminder');
            }
        }

        $newEvent = $this->client->postOutlook($this->owner->remoteCalendarUrl, $action, $timezone);
        $newEventBody = $newEvent['body'];
        $newEventId = CJSON::decode($newEventBody);
        if ($newEvent != false) {
            $newEventData = $this->client->getOutlook( "https://graph.microsoft.com/v1.0/me/events/" . $newEventId['id'], "");
            $metaData = ActionMetaData::model()->findByAttributes(array('actionId' => $action->id));
            if (!isset($metaData)) {
                $metaData = new ActionMetaData;
                $metaData->actionId = $action->id;
            }
            
            $newEventDataBody = CJSON::decode($newEventData['body']);
            $metaData->etag = $newEventDataBody['@odata.etag'];
            $metaData->remoteCalendarUrl = $newEventDataBody['id'];//$uniqueId;
            $metaData->save();     
        }
    }
   
    /**
     *
     * Sets the notification time for an action that is synced with Outlook
     */
    //private function getReminderMinutes() {

    //}
 
    /**
     * Updates a VEvent object associated with an Action and sends it to a remote CalDav server
     */
    protected function updateCalObject($action) {
        
        $eventData = $this->client->getOutlook( "https://graph.microsoft.com/v1.0/me/events/" . $action->remoteCalendarUrl, "");
        $calObj = CJSON::decode($eventData['body']);
        $timezone = "UTC";
        $this->setEventAttributes($calObj, $action);
        $this->client->patchOutlook( "https://graph.microsoft.com/v1.0/me/events/" . $action->remoteCalendarUrl, $action, $timezone);
    }
    
    /**
     * Converts an Action's attributes to CalDav friendly attributes and modifies
     * the provided VEvent with them
     */
    protected function setEventAttributes(&$vevent, $action) {

        $startTime = new Sabre\VObject\Property\DateTime('DTSTART');
        $startDateTime = new \DateTime('@' . $action->dueDate);
        $startTime->setDateTime($startDateTime);
        $endTime = new Sabre\VObject\Property\DateTime('DTEND');
        if(empty($action->completeDate)){
            $action->completeDate = $action->dueDate;
        }
        $endDateTime = new \DateTime('@' . $action->completeDate);
        $endTime->setDateTime($endDateTime);
        $vevent['start']['dateTime'] = $startTime;
        $vevent['end']['dateTime'] = $endTime;
        $vevent['subject'] = $action->actionDescription;

        return $vevent;
    }
    
    /** CUSTOM FOR OUTLOOK
     * Attempt to delete a remote calendar event associated with a given Action
     */
    //public function deleteOutlookAction($calendar, $outlookActionId) {
    public function deleteCalObject($action) {
        //if no remote then just return
        if(empty($action->remoteCalendarUrl)) return;
        $this->client->deleteOutlook( "https://graph.microsoft.com/v1.0/me/events/" . $action->remoteCalendarUrl);
    }
}

